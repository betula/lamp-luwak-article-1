Всем привет.

Сегодня я хочу рассказать всем о новой стилистике описания приложения на React на базе state management библиотеки lamp-luwak.

На текущий момент в отрасли множество подходов к организации state management вашего приложения. Я проведу небольшое сравнение с самыми популярными подходами:

redux -




mobx -



- Конечно на первом месте будут redux и mobx, как хорошо себя зарекомендовавшие подходы уже не нуждающиеся в представлении.
- Далее будут идти


Вопрос огранизации синхронизации данных и отображения вашего приложения.


В отличие от redux, у нас множество сторов и мы можем










1. Код огранизован на доступные по всему приложению сервисы, что бы можно было в любом месте любого React компонента получить инстанцию какого-угодно сервиса и либо вывести его данные, либо инициировать какое-либо действие с этим сервисом.

Сервис - это инстанция класса или функции-фабрики, представленная в единственном экземпляре, создаваемая при первом обращении и остающаяся до конца работы приложения.
Описывается ли сервис с помощью класса или функции-фабрики, внутри себя он имеет свойство `store`.
```typescript
class Todos {
	store = []
}
```
При описании свойства `store` необходимо указать значние стора по умолчанию. А так же из этого значения будут выводиться тип вашего стора для типизированных диалектов.
Далее сервис доступен либо из любого другого сервиса
```typescript
class TodoEditor {
	todos = provide(Todos)
}
```
Здесь функция `provide` возвращает инстанцию сервиса принимая в качестве аргумента класс сервиса, в данном примере `Todos`.
Либо из любого компонента
```typescript
const List = React.memo(() => {
	todos = useProvide(Todos);
	return (
		<ul>
			{todos.store.map(
				(item) => <li key={item.key}>{item.label}</li>
			)}
		</ul>
	)
})
```
Идентификатором сервиса является его класс или функция-фабрика. В React компонент инстанция необходимого сервиса поставляется через метод `useProvide`, единственный аргумент которого - класс или функция-фабрика сервиса, в данном примере `Todos`. При таком способе получения сервиса в компоненте, компонент будет автоматически подписан на изменение стора этого сервиса.

2. Стор - это иммутабельная структура данных, для модификации стора используется обычное присвоение, потому что свойство `store` после инстанциации через `provide` или `useProvide` становиться геттер/сеттером и если при присвоении приходит отличное от предыдущего значение, то все подписчики на изменение стора получат уведомление с новым и старым значением стора.

Таким образом в примере выше, компонент List будет перерисовываться каждый раз когда будет изменяться значение стора сервиса `Todos`.




Сервис может быть получен в любом месте приложения и
