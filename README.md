# Сервисно-ориентированный state management

На текущий момент в отрасли множество подходов к организации state management вашего приложения. Существующие решения хорошо задокументированы и имеют большое коммьюнити, но так же имеют и некоторые недостатки.

Благодаря тому, что React предоставляет удивительные возможности по работе с отображением, можно сосредоточиться только на организации логики приложения и семантике кода, описывающего работу с данными. Т.е. выбирая state management библиотеку, происходит выбор стилистики будущей кодовой базы. `lamp-luwak` предлагает бизнес логику разбитую на сервисы-сторы, с возможностью разбиения на независимые модули (с SSR), и использующие механизм `action` и `subscribe` для коммуникации.

В `lamp-luwak` множество сторов и мы можем не использовать селекторы, так как каждый стор должен быть организован с минимальным уровнем вложенности, а обновление таких иммутабельных структур будет проще. Так же при обновлении одного из сторов, другие сервисы и React компоненты не подписанные на него никак не будут задействованы и не будут оказывать на производительность негативного воздействия.

Вся логика внутри вашего приложения разбита на сервисы, каждый сервис содержит в себе единственный стор, изменение которого уведомляет подписчиков.
Так же внутри сервиса содержаться функции логики, где можно обращаться к другим сервисам и перезаписывать иммутабельный стор, эти функции могут быть асинхронными и содержать в себе сайд эффекты.

`lamp-luwak`, благодаря своей архитектуре, позволяет оптимизировать учаски документа необходимого для перерисовки. Локализация областей вашего отображение и минимизация затрат на обновления, происходит засчет подписывания каждого React компонента вызывающего `useProvide` или `useSubscribe` на соответствующие сторы. Обновляться будут только те компоненты, что используют сторы, которые поменялись.

Любой сервис можно инстанцировать в любом месте вашего приложения, для библиотеки не трубется какая-либо инициализация. Например это особенно удобно для разработки изолированных компонентов или embedded решений.

Так же каждый сервис может быть подписан на изменение стора любого другого сервиса или набора сервисов через механизм `subscribe`. Таким образом можно делать зависимые вычисления.

Для демонстрации стилистики кода воспользуемся примером приложения, что использует часть функциональности todo-листа для сохранения наглядности примера:
- Добавление/удаление задачи
- Завершить/возобновить каждую задачу из списка
- Счетчик завершённых/активных

### Установка

Развернём приложение todos используя `create-react-app`

```bash
npx create-react-app todos --template typescript --use-npm
# or
yarn create react-app todos --template typescript
```

Так же устанавливаем необходимые пакеты в todos приложение

```bash
npm i --save lamp-luwak
# or
yarn add lamp-luwak
```

### Организация приложения

Код огранизован на доступные по всему приложению сервисы, что бы можно было в любом месте любого React компонента получить инстанцию какого-угодно сервиса и либо вывести его данные, либо инициировать какое-либо действие с этим сервисом.

Сервис - это инстанция класса или функции-фабрики, представленная в единственном экземпляре, создаваемая при первом обращении и остающаяся до конца работы приложения.
Описывается ли сервис с помощью класса или функции-фабрики, внутри себя он имеет свойство `store`.

```typescript
class Todos {
  store = [ /*...*/ ];
  // ...
```

При описании свойства `store` необходимо указать значние стора по умолчанию. Так же из этого значения будет автоматически выводиться тип стора для типизированных диалектов.
Далее сервис доступен либо из любого другого сервиса

```typescript
class TodoCounters {
  todo = provide(Todo);
  // ...
```

Здесь функция `provide` возвращает инстанцию сервиса, принимая в качестве аргумента класс сервиса, в данном примере `Todo`.
Либо из любого React компонента

```typescript
const List = () => {
  const todo = useProvide(Todo);
  // ...
};
```

Идентификатором сервиса является его класс или функция-фабрика. В React компонент инстанция необходимого сервиса поставляется через метод `useProvide`, единственный аргумент которого - класс или функция-фабрика сервиса, в данном примере `Todo`. При таком способе получения сервиса в компоненте, компонент будет автоматически подписан на изменение стора этого сервиса.

Стор - это иммутабельная структура данных, для модификации стора используется обычное присвоение, потому что свойство `store` после инстанциации через `provide` или `useProvide` становиться геттер/сеттером и если при присвоении приходит отличное от предыдущего значение, то все подписчики на изменение стора получат уведомление с новым и старым значением стора.

Таким образом в примере выше, компонент List будет перерисовываться каждый раз когда будет изменяться значение стора сервиса `Todo`.

(Взаимодействие -)

### Структура

Положим сервисы в папку `services`, а React компоненты в папку `components` и получим следующую структуру нашего приложения.

```
srс/
  components/       // Директория с React компонентами
    App.tsx         // Компонент приложения
    Counters.tsx    // Счетчики активных и выполненных задач
    Input.tsx       // Форма для добавления новой задачи
    Item.tsx        // Задача
    List.tsx        // Список задач
  services/         // Директория с сервисами
    Todo/
      TodoItem.ts   // Задача
    Todo.ts         // Сервис списка задач
    TodoCounters.ts // Сервис счетчиков активных и выполненных задач
  index.tsx
```

### Сервисы

Для реализации нашей задачи нам потребуется комбинация из 2-х сервисов. Это будет
- `Todo` - в его сторе будет массив экземпляров задач, и у него будет метод `add` для добавления новой задачи;
- `TodoCounters` - в его сторе будет вычисленные счётчики активных задач и завершённых.

Далее необходимо подробнее рассмотреть структуру стора `Todo` сервиса, это массив из экземпляров класса `TodoItem`, т.е. это массив из других сторов. Стоит упомянуть сразу, что никакой "подписки" на вложенные сторы не происходит, это просто допустимое значени. Экземпляр стора может быть вложен в другой стор наравне с другими типами, такими как Date, Map, Set. (с SSR) Это сделано для оптимизации глубоких вложенных структур данных, что бы локализовывать области обновления UI. А так же для стилистики описания логики ближе к данным, к ней относящимся. Например в нашем примере в `TodoItem` содержиться метод `toggle`, который меняет статус завершённости задачи.

Для того, что бы создать стор (не сервис) из класса `TodoItem` нужно использовать функцию `create`, принимающую первым аргументом класс или функцию-фабрику стора, а последующие аргументы будут проброшены в конструктор класса или в аргументы функции-фабрики.

```typescript
// ./Todo.ts
import { create } from 'lamp-luwak';
import { TodoItem } from './Todo/TodoItem';

export class Todo {
  store = [
    create(TodoItem, { id: 1, label: 'Cook the dinner', completed: false }),
    create(TodoItem, { id: 2, label: 'Cook the breakfast', completed: true })
  ]
  add(label: string) {
    this.store = this.store.concat(
      create(TodoItem, { id: Date.now(), label, completed: false })
    );
  }
}
```

Создаём сервис `Todo`. В `store` по умолчанию положим два экземпляра стора задачи `TodoItem`, создав их через функцию `create`. И добавляем метод `add`, который пересоздаёт стор добавляя в него новый экземпляр задачи `TodoItem`, в качестве уникального `id`, использовано значение вызова `Date.now`.

```typescript
// ./Todo/TodoItem.ts
import { subscribe, modify, action } from 'lamp-luwak';

type Store = {
  id: number,
  label: string,
  completed: boolean
}

export const TodoItemChanged = action();

export class TodoItem {
  store: Store;
  constructor(store: Store) {
    this.store = store;
    subscribe(this, TodoItemChanged);
  }
  toggle() {
    modify(this).completed = !this.store.completed;
  }
}
```







```typescript
// ./TodoCounters.ts
import { provide, subscribe } from 'lamp-luwak';
import { Todo } from './Todo';
import { TodoItemChanged } from './Todo/TodoItem';

export class TodoCounters {
  todo = provide(Todo);
  store = {
    active: 0,
    completed: 0
  }
  constructor() {
    subscribe(this.todo, this.calculate, this);
    subscribe(TodoItemChanged, this.calculate, this);
    this.calculate();
  }
  calculate() {
    const items = this.todo.store;
    const completed = items.filter(item => item.store.completed).length;
    const active = items.length - completed;
    this.store = { completed, active };
  }
}
```











