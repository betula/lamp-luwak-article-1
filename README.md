
На текущий момент в отрасли множество подходов к организации state management вашего приложения. Существующие решения хорошо задокументированы и имеют большое коммьюнити, но так же имеют и некоторые недостатки.

Благодаря тому, что React предоставляет удивительные возможности по работе с отображением, можно сосредоточиться только на организации логики приложения и семантике кода описывающего работу с данными. Т.е. выбирая state management библиотеку, происходит выбор стилистики будущей кодовой базы. `lamp-luwak` предлагает бизнес логику разбитую на сервисы-сторы, с возможностью разбиения на независимые модули (с SSR), и использующие механизм `action` и `subscribe` для коммуникации.

В `lamp-luwak` множество сторов и мы можем не использовать селекторы, так как каждый стор должен быть организован с минимальным уровнем вложенности, а обновление таких иммутабельных структур будет проще. Так же при обновлении одного из сторов, другие сервисы и React компоненты не подписанные на него никак не будут задействованы и не будут оказывать на производительность негативного воздействия.

Вся логика внутри вашего приложения разбита на сервисы, каждый сервис содержит в себе единственный стор, изменение которого уведомляет подписчиков.
Так же внутри сервиса содержаться функции логики, где можно обращаться к другим сервисам и перезаписывать иммутабельный стор, эти функции могут быть асинхронными и содержать в себе сайд эффекты.

Удачная комбинация сервиса с единственным иммутабельным стором, дала преимущества сервисно-ориентированного подхода и не принудила вводить дополнительные синтаксические конструкции для декорирования свойств класса и работы с множеством вложенных источников изменяющихся данных.

Любой сервис можно инстанцировать в любом месте вашего приложения, для библиотеки не трубется какая-либо инициализация. Например это особенно удобно для разработки изолированных компонентов или embedded решений.

Так же каждый сервис может быть подписан на изменение стора любого другого сервиса или набора сервисов через механизм `subscribe`. Таким образом можно делать зависимые вычисления.

Для демонстрации стилистики кода воспользуемся традиционным примером Todos приложения. Возьмем только часть функциональности todos для сохранения наглядности примера:
- Добавление/удаление задач
- Завершить/возобновить каждую задачу из списка
- Фильтр завершённых/активных

### Установка

Развернём приложение todos используя `create-react-app`

```bash
npx create-react-app todos --template typescript --use-npm
# or
yarn create react-app todos --template typescript
```

Так же устанавливаем необходимые пакеты в todos приложение

```bash
npm i --save lamp-luwak todomvc-app-css
# or
yarn add lamp-luwak todomvc-app-css
```

### Структура



1. Код огранизован на доступные по всему приложению сервисы, что бы можно было в любом месте любого React компонента получить инстанцию какого-угодно сервиса и либо вывести его данные, либо инициировать какое-либо действие с этим сервисом.

Сервис - это инстанция класса или функции-фабрики, представленная в единственном экземпляре, создаваемая при первом обращении и остающаяся до конца работы приложения.
Описывается ли сервис с помощью класса или функции-фабрики, внутри себя он имеет свойство `store`.
```typescript
class Todos {
	store = []
}
```
При описании свойства `store` необходимо указать значние стора по умолчанию. А так же из этого значения будут выводиться тип вашего стора для типизированных диалектов.
Далее сервис доступен либо из любого другого сервиса
```typescript
class TodoEditor {
	todos = provide(Todos)
}
```
Здесь функция `provide` возвращает инстанцию сервиса принимая в качестве аргумента класс сервиса, в данном примере `Todos`.
Либо из любого компонента
```typescript
const List = React.memo(() => {
	todos = useProvide(Todos);
	return (
		<ul>
			{todos.store.map(
				(item) => <li key={item.key}>{item.label}</li>
			)}
		</ul>
	)
})
```
Идентификатором сервиса является его класс или функция-фабрика. В React компонент инстанция необходимого сервиса поставляется через метод `useProvide`, единственный аргумент которого - класс или функция-фабрика сервиса, в данном примере `Todos`. При таком способе получения сервиса в компоненте, компонент будет автоматически подписан на изменение стора этого сервиса.

2. Стор - это иммутабельная структура данных, для модификации стора используется обычное присвоение, потому что свойство `store` после инстанциации через `provide` или `useProvide` становиться геттер/сеттером и если при присвоении приходит отличное от предыдущего значение, то все подписчики на изменение стора получат уведомление с новым и старым значением стора.

Таким образом в примере выше, компонент List будет перерисовываться каждый раз когда будет изменяться значение стора сервиса `Todos`.




3. Взаимодействие -


Сервис может быть получен в любом месте приложения и







------------



